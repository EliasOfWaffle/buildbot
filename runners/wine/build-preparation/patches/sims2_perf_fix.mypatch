From: Zhiyi Zhang <zzhang@codeweavers.com>
Subject: [PATCH 1/6] user32: Optimize getting monitor count with GetSystemMetrics().
Message-Id: <51b03272-8028-3473-a82e-41b8ec8d7c41@codeweavers.com>
Date: Tue, 18 May 2021 17:11:02 +0800

This saves calls to GetMonitorInfo().

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/user32/sysparams.c | 19 +++++++++++++++++--
 1 file changed, 17 insertions(+), 2 deletions(-)

diff --git a/dlls/user32/sysparams.c b/dlls/user32/sysparams.c
index 0b4dbfc2d78..7dc2a8df645 100644
--- a/dlls/user32/sysparams.c
+++ b/dlls/user32/sysparams.c
@@ -371,6 +371,22 @@ RECT get_virtual_screen_rect(void)
     return info.virtual_rect;
 }
 
+static BOOL CALLBACK get_monitor_count_proc( HMONITOR monitor, HDC hdc, LPRECT rect, LPARAM lp )
+{
+    INT *count = (INT *)lp;
+
+    ++(*count);
+    return TRUE;
+}
+
+static INT get_monitor_count(void)
+{
+    INT count = 0;
+
+    EnumDisplayMonitors( 0, NULL, get_monitor_count_proc, (LPARAM)&count );
+    return count;
+}
+
 static BOOL get_primary_adapter(WCHAR *name)
 {
     DISPLAY_DEVICEW dd;
@@ -2717,8 +2733,7 @@ INT WINAPI GetSystemMetrics( INT index )
         get_monitors_info( &info );
         return info.virtual_rect.bottom - info.virtual_rect.top;
     case SM_CMONITORS:
-        get_monitors_info( &info );
-        return info.count;
+        return get_monitor_count();
     case SM_SAMEDISPLAYFORMAT:
         return 1;
     case SM_IMMENABLED:

-- 
2.30.2

From: Zhiyi Zhang <zzhang@codeweavers.com>
Subject: [PATCH 2/6] user32: Optimize getting primary monitor rectangle with GetSystemMetrics().
Message-Id: <c6d907f5-b564-a6a4-3d0c-85785ce71eed@codeweavers.com>
Date: Tue, 18 May 2021 17:11:10 +0800

This saves calls to GetMonitorInfo() and return from EnumDisplayMonitors() immediately
after the primary monitor is found.

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/user32/sysparams.c | 30 ++++++++++++++++++++++++++----
 1 file changed, 26 insertions(+), 4 deletions(-)

diff --git a/dlls/user32/sysparams.c b/dlls/user32/sysparams.c
index 7dc2a8df645..ab1c5af0c1b 100644
--- a/dlls/user32/sysparams.c
+++ b/dlls/user32/sysparams.c
@@ -371,6 +371,27 @@ RECT get_virtual_screen_rect(void)
     return info.virtual_rect;
 }
 
+static BOOL CALLBACK get_primary_monitor_proc( HMONITOR monitor, HDC hdc, LPRECT rect, LPARAM lp )
+{
+    RECT *primary_rect = (RECT *)lp;
+
+    if (!rect->top && !rect->left && rect->right && rect->bottom)
+    {
+        *primary_rect = *rect;
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static RECT get_primary_monitor_rect(void)
+{
+    RECT rect = {0};
+
+    EnumDisplayMonitors( 0, NULL, get_primary_monitor_proc, (LPARAM)&rect );
+    return rect;
+}
+
 static BOOL CALLBACK get_monitor_count_proc( HMONITOR monitor, HDC hdc, LPRECT rect, LPARAM lp )
 {
     INT *count = (INT *)lp;
@@ -2510,6 +2531,7 @@ INT WINAPI GetSystemMetrics( INT index )
     NONCLIENTMETRICSW ncm;
     MINIMIZEDMETRICS mm;
     ICONMETRICSW im;
+    RECT rect;
     UINT ret;
     HDC hdc;
 
@@ -2715,11 +2737,11 @@ INT WINAPI GetSystemMetrics( INT index )
     case SM_MOUSEWHEELPRESENT:
         return 1;
     case SM_CXSCREEN:
-        get_monitors_info( &info );
-        return info.primary_rect.right - info.primary_rect.left;
+        rect = get_primary_monitor_rect();
+        return rect.right - rect.left;
     case SM_CYSCREEN:
-        get_monitors_info( &info );
-        return info.primary_rect.bottom - info.primary_rect.top;
+        rect = get_primary_monitor_rect();
+        return rect.bottom - rect.top;
     case SM_XVIRTUALSCREEN:
         get_monitors_info( &info );
         return info.virtual_rect.left;

-- 
2.30.2

From: Zhiyi Zhang <zzhang@codeweavers.com>
Subject: [PATCH 3/6] user32: Optimize getting virtual screen rectangle with GetSystemMetrics().
Message-Id: <7c05a23f-457c-44ff-c30c-d70a9ec203dc@codeweavers.com>
Date: Tue, 18 May 2021 17:11:18 +0800

This saves calls to GetMonitorInfo().

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/user32/sysparams.c | 49 +++++++++++++----------------------------
 1 file changed, 15 insertions(+), 34 deletions(-)

diff --git a/dlls/user32/sysparams.c b/dlls/user32/sysparams.c
index ab1c5af0c1b..3d0cb2a6566 100644
--- a/dlls/user32/sysparams.c
+++ b/dlls/user32/sysparams.c
@@ -337,38 +337,20 @@ static void SYSPARAMS_NonClientMetrics32ATo32W( const NONCLIENTMETRICSA* lpnm32A
 
 /* Helper functions to retrieve monitors info */
 
-struct monitor_info
+static BOOL CALLBACK get_virtual_screen_proc( HMONITOR monitor, HDC hdc, LPRECT rect, LPARAM lp )
 {
-    int count;
-    RECT primary_rect;
-    RECT virtual_rect;
-};
+    RECT *virtual_rect = (RECT *)lp;
 
-static BOOL CALLBACK monitor_info_proc( HMONITOR monitor, HDC hdc, LPRECT rect, LPARAM lp )
-{
-    MONITORINFO mi;
-    struct monitor_info *info = (struct monitor_info *)lp;
-    info->count++;
-    UnionRect( &info->virtual_rect, &info->virtual_rect, rect );
-    mi.cbSize = sizeof(mi);
-    if (GetMonitorInfoW( monitor, &mi ) && (mi.dwFlags & MONITORINFOF_PRIMARY))
-        info->primary_rect = mi.rcMonitor;
+    UnionRect( virtual_rect, virtual_rect, rect );
     return TRUE;
 }
 
-static void get_monitors_info( struct monitor_info *info )
-{
-    info->count = 0;
-    SetRectEmpty( &info->primary_rect );
-    SetRectEmpty( &info->virtual_rect );
-    EnumDisplayMonitors( 0, NULL, monitor_info_proc, (LPARAM)info );
-}
-
 RECT get_virtual_screen_rect(void)
 {
-    struct monitor_info info;
-    get_monitors_info( &info );
-    return info.virtual_rect;
+    RECT rect = {0};
+
+    EnumDisplayMonitors( 0, NULL, get_virtual_screen_proc, (LPARAM)&rect );
+    return rect;
 }
 
 static BOOL CALLBACK get_primary_monitor_proc( HMONITOR monitor, HDC hdc, LPRECT rect, LPARAM lp )
@@ -2527,7 +2509,6 @@ BOOL WINAPI SystemParametersInfoA( UINT uiAction, UINT uiParam,
  */
 INT WINAPI GetSystemMetrics( INT index )
 {
-    struct monitor_info info;
     NONCLIENTMETRICSW ncm;
     MINIMIZEDMETRICS mm;
     ICONMETRICSW im;
@@ -2743,17 +2724,17 @@ INT WINAPI GetSystemMetrics( INT index )
         rect = get_primary_monitor_rect();
         return rect.bottom - rect.top;
     case SM_XVIRTUALSCREEN:
-        get_monitors_info( &info );
-        return info.virtual_rect.left;
+        rect = get_virtual_screen_rect();
+        return rect.left;
     case SM_YVIRTUALSCREEN:
-        get_monitors_info( &info );
-        return info.virtual_rect.top;
+        rect = get_virtual_screen_rect();
+        return rect.top;
     case SM_CXVIRTUALSCREEN:
-        get_monitors_info( &info );
-        return info.virtual_rect.right - info.virtual_rect.left;
+        rect = get_virtual_screen_rect();
+        return rect.right - rect.left;
     case SM_CYVIRTUALSCREEN:
-        get_monitors_info( &info );
-        return info.virtual_rect.bottom - info.virtual_rect.top;
+        rect = get_virtual_screen_rect();
+        return rect.bottom - rect.top;
     case SM_CMONITORS:
         return get_monitor_count();
     case SM_SAMEDISPLAYFORMAT:

-- 
2.30.2

From: Zhiyi Zhang <zzhang@codeweavers.com>
Subject: [PATCH 4/6] user32: Use get_primary_monitor_rect() helper.
Message-Id: <c8ca10a2-f194-ea82-9715-3586d3ccad8a@codeweavers.com>
Date: Tue, 18 May 2021 17:11:25 +0800

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/user32/input.c        | 16 +++++++---------
 dlls/user32/sysparams.c    |  6 ++----
 dlls/user32/user_private.h |  1 +
 dlls/user32/win.c          |  3 +--
 dlls/user32/winpos.c       |  7 ++++---
 5 files changed, 15 insertions(+), 18 deletions(-)

diff --git a/dlls/user32/input.c b/dlls/user32/input.c
index ba0292c8f88..b4e3579f5e8 100644
--- a/dlls/user32/input.c
+++ b/dlls/user32/input.c
@@ -195,17 +195,15 @@ static void update_mouse_coords( INPUT *input )
     if (input->u.mi.dwFlags & MOUSEEVENTF_ABSOLUTE)
     {
         DPI_AWARENESS_CONTEXT context = SetThreadDpiAwarenessContext( DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE );
+        RECT rc;
+
         if (input->u.mi.dwFlags & MOUSEEVENTF_VIRTUALDESK)
-        {
-            RECT rc = get_virtual_screen_rect();
-            input->u.mi.dx = rc.left + ((input->u.mi.dx * (rc.right - rc.left)) >> 16);
-            input->u.mi.dy = rc.top  + ((input->u.mi.dy * (rc.bottom - rc.top)) >> 16);
-        }
+            rc = get_virtual_screen_rect();
         else
-        {
-            input->u.mi.dx = (input->u.mi.dx * GetSystemMetrics( SM_CXSCREEN )) >> 16;
-            input->u.mi.dy = (input->u.mi.dy * GetSystemMetrics( SM_CYSCREEN )) >> 16;
-        }
+            rc = get_primary_monitor_rect();
+
+        input->u.mi.dx = rc.left + ((input->u.mi.dx * (rc.right - rc.left)) >> 16);
+        input->u.mi.dy = rc.top  + ((input->u.mi.dy * (rc.bottom - rc.top)) >> 16);
         SetThreadDpiAwarenessContext( context );
     }
     else
diff --git a/dlls/user32/sysparams.c b/dlls/user32/sysparams.c
index 3d0cb2a6566..015db0db50e 100644
--- a/dlls/user32/sysparams.c
+++ b/dlls/user32/sysparams.c
@@ -366,7 +366,7 @@ static BOOL CALLBACK get_primary_monitor_proc( HMONITOR monitor, HDC hdc, LPRECT
     return TRUE;
 }
 
-static RECT get_primary_monitor_rect(void)
+RECT get_primary_monitor_rect(void)
 {
     RECT rect = {0};
 
@@ -1818,9 +1818,7 @@ BOOL WINAPI SystemParametersInfoW( UINT uiAction, UINT uiParam,
         spi_idx = SPI_SETWORKAREA_IDX;
         if (!spi_loaded[spi_idx])
         {
-            SetRect( &work_area, 0, 0,
-                     GetSystemMetrics( SM_CXSCREEN ),
-                     GetSystemMetrics( SM_CYSCREEN ) );
+            work_area = get_primary_monitor_rect();
             EnumDisplayMonitors( 0, NULL, enum_monitors, (LPARAM)&work_area );
             spi_loaded[spi_idx] = TRUE;
         }
diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
index 974d18be482..82cf376ef54 100644
--- a/dlls/user32/user_private.h
+++ b/dlls/user32/user_private.h
@@ -261,6 +261,7 @@ extern void update_window_state( HWND hwnd ) DECLSPEC_HIDDEN;
 extern void wait_graphics_driver_ready(void) DECLSPEC_HIDDEN;
 extern void *get_hook_proc( void *proc, const WCHAR *module, HMODULE *free_module ) DECLSPEC_HIDDEN;
 extern RECT get_virtual_screen_rect(void) DECLSPEC_HIDDEN;
+extern RECT get_primary_monitor_rect(void) DECLSPEC_HIDDEN;
 extern LRESULT call_current_hook( HHOOK hhook, INT code, WPARAM wparam, LPARAM lparam ) DECLSPEC_HIDDEN;
 extern DWORD get_input_codepage( void ) DECLSPEC_HIDDEN;
 extern BOOL map_wparam_AtoW( UINT message, WPARAM *wparam, enum wm_char_mapping mapping ) DECLSPEC_HIDDEN;
diff --git a/dlls/user32/win.c b/dlls/user32/win.c
index 680defc2071..86a1f50ca77 100644
--- a/dlls/user32/win.c
+++ b/dlls/user32/win.c
@@ -855,8 +855,7 @@ BOOL WIN_GetRectangles( HWND hwnd, enum coords_relative relative, RECT *rectWind
         }
         else
         {
-            rect.right  = GetSystemMetrics(SM_CXSCREEN);
-            rect.bottom = GetSystemMetrics(SM_CYSCREEN);
+            rect = get_primary_monitor_rect();
         }
         if (rectWindow) *rectWindow = rect;
         if (rectClient) *rectClient = rect;
diff --git a/dlls/user32/winpos.c b/dlls/user32/winpos.c
index de5d50d4c3a..5a2b8ccdfe8 100644
--- a/dlls/user32/winpos.c
+++ b/dlls/user32/winpos.c
@@ -740,7 +740,7 @@ MINMAXINFO WINPOS_GetMinMaxInfo( HWND hwnd )
 
     if ((monitor = MonitorFromWindow( hwnd, MONITOR_DEFAULTTOPRIMARY )))
     {
-        RECT rc_work;
+        RECT rc_work, rc_primary;
         MONITORINFO mon_info;
 
         mon_info.cbSize = sizeof(mon_info);
@@ -754,8 +754,9 @@ MINMAXINFO WINPOS_GetMinMaxInfo( HWND hwnd )
                 rc_work = mon_info.rcWork;
         }
 
-        if (MinMax.ptMaxSize.x == GetSystemMetrics(SM_CXSCREEN) + 2 * xinc &&
-            MinMax.ptMaxSize.y == GetSystemMetrics(SM_CYSCREEN) + 2 * yinc)
+        rc_primary = get_primary_monitor_rect();
+        if (MinMax.ptMaxSize.x == (rc_primary.right - rc_primary.left) + 2 * xinc &&
+            MinMax.ptMaxSize.y == (rc_primary.bottom - rc_primary.top) + 2 * yinc)
         {
             MinMax.ptMaxSize.x = (rc_work.right - rc_work.left) + 2 * xinc;
             MinMax.ptMaxSize.y = (rc_work.bottom - rc_work.top) + 2 * yinc;

-- 
2.30.2

From: Zhiyi Zhang <zzhang@codeweavers.com>
Subject: [PATCH 5/6] user32: Add a cache for EnumDisplayDevicesW().
Message-Id: <0e70d733-e37f-bfa7-4785-a5713f10d28d@codeweavers.com>
Date: Tue, 18 May 2021 17:14:18 +0800

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
You might notice that there are duplications with update_display_cache() and update_monitor_cache().
EnumDisplayMonitors() is planned to use wineserver calls directly and subsequently update_monitor_cache()
will be removed. So I don't try to deduplicate the code.

 dlls/user32/sysparams.c | 313 ++++++++++++++++++++++++++++------------
 1 file changed, 218 insertions(+), 95 deletions(-)

diff --git a/dlls/user32/sysparams.c b/dlls/user32/sysparams.c
index 015db0db50e..0336bf943c4 100644
--- a/dlls/user32/sysparams.c
+++ b/dlls/user32/sysparams.c
@@ -107,6 +107,32 @@ DEFINE_DEVPROPKEY(WINE_DEVPROPKEY_MONITOR_ADAPTERNAME, 0x233a9ef3, 0xafc4, 0x4ab
 
 #define NULLDRV_DEFAULT_HMONITOR ((HMONITOR)(UINT_PTR)(0x10000 + 1))
 
+/* Cached display device information */
+struct display_device
+{
+    struct list entry;         /* Device list entry */
+    struct list childs;        /* Child device list entry. For adapters, this is monitor list. For monitors, this is unused. */
+    WCHAR device_name[32];     /* as DeviceName in DISPLAY_DEVICEW */
+    WCHAR device_string[128];  /* as DeviceString in DISPLAY_DEVICEW */
+    DWORD state_flags;         /* as StateFlags in DISPLAY_DEVICEW */
+    WCHAR device_id[128];      /* as DeviceID in DISPLAY_DEVICEW when EDD_GET_DEVICE_INTERFACE_NAME is not set */
+    WCHAR interface_name[128]; /* as DeviceID in DISPLAY_DEVICEW when EDD_GET_DEVICE_INTERFACE_NAME is set */
+    WCHAR device_key[128];     /* as DeviceKey in DISPLAY_DEVICEW */
+};
+
+static struct list adapters = LIST_INIT(adapters);
+static FILETIME last_query_display_time;
+static CRITICAL_SECTION display_section;
+static CRITICAL_SECTION_DEBUG display_critsect_debug =
+{
+    0, 0, &display_section,
+    { &display_critsect_debug.ProcessLocksList, &display_critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": display_section") }
+};
+static CRITICAL_SECTION display_section = { &display_critsect_debug, -1, 0, 0, 0, 0 };
+
+static BOOL enum_display_device( WCHAR *device, DWORD index, struct display_device *info );
+
 /* Cached monitor information */
 static MONITORINFOEXW *monitors;
 static UINT monitor_count;
@@ -3791,6 +3817,69 @@ HMONITOR WINAPI MonitorFromWindow(HWND hWnd, DWORD dwFlags)
     return MonitorFromRect( &rect, dwFlags );
 }
 
+/* Return FALSE on failure and TRUE on success */
+static BOOL update_display_cache(void)
+{
+    struct display_device device, *adapter, *adapter2, *monitor, *monitor2;
+    DWORD adapter_idx, monitor_idx;
+    struct list *monitor_list;
+    FILETIME filetime = {0};
+    HANDLE mutex = NULL;
+    BOOL ret = FALSE;
+
+    /* Update display cache from SetupAPI if it's outdated */
+    wait_graphics_driver_ready();
+
+    if (!video_key && RegOpenKeyW( HKEY_LOCAL_MACHINE, L"HARDWARE\\DEVICEMAP\\VIDEO", &video_key ))
+        return FALSE;
+    if (RegQueryInfoKeyW( video_key, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &filetime ))
+        return FALSE;
+    if (CompareFileTime( &filetime, &last_query_display_time ) < 1)
+        return TRUE;
+
+    mutex = get_display_device_init_mutex();
+    EnterCriticalSection( &display_section );
+
+    LIST_FOR_EACH_ENTRY_SAFE(adapter, adapter2, &adapters, struct display_device, entry)
+    {
+        LIST_FOR_EACH_ENTRY_SAFE(monitor, monitor2, &adapter->childs, struct display_device, entry)
+        {
+            list_remove( &monitor->entry );
+            heap_free( monitor );
+        }
+        list_remove( &adapter->entry );
+        heap_free( adapter );
+    }
+
+    for (adapter_idx = 0; enum_display_device( NULL, adapter_idx, &device ); ++adapter_idx)
+    {
+        adapter = heap_alloc( sizeof(*adapter) );
+        if (!adapter)
+            goto fail;
+
+        memcpy( adapter, &device, sizeof(device) );
+        monitor_list = &adapter->childs;
+        list_init( monitor_list );
+        list_add_tail( &adapters, &adapter->entry );
+        for (monitor_idx = 0; enum_display_device( adapter->device_name, monitor_idx, &device ); ++monitor_idx)
+        {
+            monitor = heap_alloc( sizeof(*monitor) );
+            if (!monitor)
+                goto fail;
+
+            memcpy( monitor, &device, sizeof(device) );
+            list_add_tail( monitor_list, &monitor->entry );
+        }
+    }
+
+    last_query_display_time = filetime;
+    ret = TRUE;
+fail:
+    LeaveCriticalSection( &display_section );
+    release_display_device_init_mutex( mutex );
+    return ret;
+}
+
 /* Return FALSE on failure and TRUE on success */
 static BOOL update_monitor_cache(void)
 {
@@ -4117,6 +4206,76 @@ BOOL WINAPI EnumDisplayDevicesA( LPCSTR device, DWORD index, DISPLAY_DEVICEA *in
  *		EnumDisplayDevicesW (USER32.@)
  */
 BOOL WINAPI EnumDisplayDevicesW( LPCWSTR device, DWORD index, DISPLAY_DEVICEW *info, DWORD flags )
+{
+    struct display_device *adapter, *monitor, *found = NULL;
+    DWORD device_idx = 0;
+
+    TRACE("%s %u %p %#x\n", debugstr_w( device ), index, info, flags);
+
+    if (!update_display_cache())
+        return FALSE;
+
+    EnterCriticalSection( &display_section );
+    /* Enumerate adapters */
+    if (!device)
+    {
+        LIST_FOR_EACH_ENTRY(adapter, &adapters, struct display_device, entry)
+        {
+            if (index == device_idx++)
+            {
+                found = adapter;
+                break;
+            }
+        }
+    }
+    /* Enumerate monitors */
+    else
+    {
+        LIST_FOR_EACH_ENTRY(adapter, &adapters, struct display_device, entry)
+        {
+            if (!lstrcmpiW( device, adapter->device_name ))
+            {
+                found = adapter;
+                break;
+            }
+        }
+
+        if (found)
+        {
+            found = NULL;
+            LIST_FOR_EACH_ENTRY(monitor, &adapter->childs, struct display_device, entry)
+            {
+                if (index == device_idx++)
+                {
+                    found = monitor;
+                    break;
+                }
+            }
+        }
+    }
+
+    if (!found)
+    {
+        LeaveCriticalSection( &display_section );
+        return FALSE;
+    }
+
+    if (info->cb >= offsetof(DISPLAY_DEVICEW, DeviceName) + sizeof(info->DeviceName))
+        lstrcpyW( info->DeviceName, found->device_name );
+    if (info->cb >= offsetof(DISPLAY_DEVICEW, DeviceString) + sizeof(info->DeviceString))
+        lstrcpyW( info->DeviceString, found->device_string );
+    if (info->cb >= offsetof(DISPLAY_DEVICEW, StateFlags) + sizeof(info->StateFlags))
+        info->StateFlags = found->state_flags;
+    if (info->cb >= offsetof(DISPLAY_DEVICEW, DeviceID) + sizeof(info->DeviceID))
+        lstrcpyW( info->DeviceID, (flags & EDD_GET_DEVICE_INTERFACE_NAME) ? found->interface_name : found->device_id );
+    if (info->cb >= offsetof(DISPLAY_DEVICEW, DeviceKey) + sizeof(info->DeviceKey))
+        lstrcpyW( info->DeviceKey, found->device_key );
+    LeaveCriticalSection( &display_section );
+    return TRUE;
+}
+
+/* Call this function with the display_device_init mutex held */
+static BOOL enum_display_device( WCHAR *device, DWORD index, struct display_device *info )
 {
     SP_DEVINFO_DATA device_data = {sizeof(device_data)};
     HDEVINFO set = INVALID_HANDLE_VALUE;
@@ -4125,17 +4284,11 @@ BOOL WINAPI EnumDisplayDevicesW( LPCWSTR device, DWORD index, DISPLAY_DEVICEW *i
     WCHAR bufferW[1024];
     LONG adapter_index;
     WCHAR *next_charW;
-    HANDLE mutex;
     DWORD size;
     DWORD type;
     HKEY hkey;
     BOOL ret = FALSE;
 
-    TRACE("%s %d %p %#x\n", debugstr_w( device ), index, info, flags);
-
-    wait_graphics_driver_ready();
-    mutex = get_display_device_init_mutex();
-
     /* Find adapter */
     if (!device)
     {
@@ -4145,46 +4298,40 @@ BOOL WINAPI EnumDisplayDevicesW( LPCWSTR device, DWORD index, DISPLAY_DEVICEW *i
             goto done;
 
         /* DeviceKey */
-        if (info->cb >= offsetof(DISPLAY_DEVICEW, DeviceKey) + sizeof(info->DeviceKey))
-            lstrcpyW( info->DeviceKey, bufferW );
+        lstrcpyW( info->device_key, bufferW );
 
         /* DeviceName */
-        swprintf( info->DeviceName, ARRAY_SIZE(info->DeviceName), L"\\\\.\\DISPLAY%d", index + 1 );
+        swprintf( info->device_name, ARRAY_SIZE(info->device_name), L"\\\\.\\DISPLAY%d", index + 1 );
 
         /* Strip \Registry\Machine\ */
         lstrcpyW( key_nameW, bufferW + 18 );
 
         /* DeviceString */
-        size = sizeof(info->DeviceString);
+        size = sizeof(info->device_string);
         if (RegGetValueW( HKEY_LOCAL_MACHINE, key_nameW, L"DriverDesc", RRF_RT_REG_SZ, NULL,
-                          info->DeviceString, &size ))
+                          info->device_string, &size ))
             goto done;
 
         /* StateFlags */
-        size = sizeof(info->StateFlags);
+        size = sizeof(info->state_flags);
         if (RegGetValueW( HKEY_CURRENT_CONFIG, key_nameW, L"StateFlags", RRF_RT_REG_DWORD, NULL,
-                          &info->StateFlags, &size ))
+                          &info->state_flags, &size ))
             goto done;
 
+        /* Interface name */
+        info->interface_name[0] = 0;
+
         /* DeviceID */
-        if (info->cb >= offsetof(DISPLAY_DEVICEW, DeviceID) + sizeof(info->DeviceID))
-        {
-            if (flags & EDD_GET_DEVICE_INTERFACE_NAME)
-                info->DeviceID[0] = 0;
-            else
-            {
-                size = sizeof(bufferW);
-                if (RegGetValueW( HKEY_CURRENT_CONFIG, key_nameW, L"GPUID", RRF_RT_REG_SZ | RRF_ZEROONFAILURE, NULL,
-                                  bufferW, &size ))
-                    goto done;
-                set = SetupDiCreateDeviceInfoList( &GUID_DEVCLASS_DISPLAY, NULL );
-                if (!SetupDiOpenDeviceInfoW( set, bufferW, NULL, 0, &device_data )
-                    || !SetupDiGetDeviceRegistryPropertyW( set, &device_data, SPDRP_HARDWAREID, NULL, (BYTE *)bufferW,
-                                                           sizeof(bufferW), NULL ))
-                    goto done;
-                lstrcpyW( info->DeviceID, bufferW );
-            }
-        }
+        size = sizeof(bufferW);
+        if (RegGetValueW( HKEY_CURRENT_CONFIG, key_nameW, L"GPUID", RRF_RT_REG_SZ | RRF_ZEROONFAILURE, NULL,
+                          bufferW, &size ))
+            goto done;
+        set = SetupDiCreateDeviceInfoList( &GUID_DEVCLASS_DISPLAY, NULL );
+        if (!SetupDiOpenDeviceInfoW( set, bufferW, NULL, 0, &device_data )
+            || !SetupDiGetDeviceRegistryPropertyW( set, &device_data, SPDRP_HARDWAREID, NULL, (BYTE *)bufferW,
+                                                   sizeof(bufferW), NULL ))
+            goto done;
+        lstrcpyW( info->device_id, bufferW );
     }
     /* Find monitor */
     else
@@ -4201,7 +4348,7 @@ BOOL WINAPI EnumDisplayDevicesW( LPCWSTR device, DWORD index, DISPLAY_DEVICEW *i
             goto done;
 
         /* DeviceName */
-        swprintf( info->DeviceName, ARRAY_SIZE(info->DeviceName), L"\\\\.\\DISPLAY%d\\Monitor%d", adapter_index, index );
+        swprintf( info->device_name, ARRAY_SIZE(info->device_name), L"\\\\.\\DISPLAY%d\\Monitor%d", adapter_index, index );
 
         /* Get monitor instance */
         /* Strip \Registry\Machine\ first */
@@ -4218,63 +4365,51 @@ BOOL WINAPI EnumDisplayDevicesW( LPCWSTR device, DWORD index, DISPLAY_DEVICEW *i
 
         /* StateFlags */
         if (!SetupDiGetDevicePropertyW( set, &device_data, &WINE_DEVPROPKEY_MONITOR_STATEFLAGS, &type,
-                                        (BYTE *)&info->StateFlags, sizeof(info->StateFlags), NULL, 0 ))
+                                        (BYTE *)&info->state_flags, sizeof(info->state_flags), NULL, 0 ))
             goto done;
 
         /* DeviceString */
         if (!SetupDiGetDeviceRegistryPropertyW( set, &device_data, SPDRP_DEVICEDESC, NULL,
-                                                (BYTE *)info->DeviceString,
-                                                sizeof(info->DeviceString), NULL ))
+                                                (BYTE *)info->device_string,
+                                                sizeof(info->device_string), NULL ))
             goto done;
 
         /* DeviceKey */
-        if (info->cb >= offsetof(DISPLAY_DEVICEW, DeviceKey) + sizeof(info->DeviceKey))
-        {
-            if (!SetupDiGetDeviceRegistryPropertyW( set, &device_data, SPDRP_DRIVER, NULL, (BYTE *)bufferW,
-                                                    sizeof(bufferW), NULL ))
-                goto done;
+        if (!SetupDiGetDeviceRegistryPropertyW( set, &device_data, SPDRP_DRIVER, NULL, (BYTE *)bufferW,
+                                                sizeof(bufferW), NULL ))
+            goto done;
 
-            lstrcpyW( info->DeviceKey, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Class\\" );
-            lstrcatW( info->DeviceKey, bufferW );
+        lstrcpyW( info->device_key, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Class\\" );
+        lstrcatW( info->device_key, bufferW );
+
+        /* Interface name */
+        lstrcpyW( info->interface_name, L"\\\\\?\\" );
+        lstrcatW( info->interface_name, instanceW );
+        lstrcatW( info->interface_name, L"#{e6f07b5f-ee97-4a90-b076-33f57bf4eaa7}" );
+        /* Replace '\\' with '#' after prefix */
+        for (next_charW = info->interface_name + lstrlenW( L"\\\\\?\\" ); *next_charW; next_charW++)
+        {
+            if (*next_charW == '\\')
+                *next_charW = '#';
         }
 
         /* DeviceID */
-        if (info->cb >= offsetof(DISPLAY_DEVICEW, DeviceID) + sizeof(info->DeviceID))
-        {
-            if (flags & EDD_GET_DEVICE_INTERFACE_NAME)
-            {
-                lstrcpyW( info->DeviceID, L"\\\\\?\\" );
-                lstrcatW( info->DeviceID, instanceW );
-                lstrcatW( info->DeviceID, L"#{e6f07b5f-ee97-4a90-b076-33f57bf4eaa7}" );
-                /* Replace '\\' with '#' after prefix */
-                for (next_charW = info->DeviceID + lstrlenW( L"\\\\\?\\" ); *next_charW;
-                     next_charW++)
-                {
-                    if (*next_charW == '\\')
-                        *next_charW = '#';
-                }
-            }
-            else
-            {
-                if (!SetupDiGetDeviceRegistryPropertyW( set, &device_data, SPDRP_HARDWAREID, NULL, (BYTE *)bufferW,
-                                                        sizeof(bufferW), NULL ))
-                    goto done;
+        if (!SetupDiGetDeviceRegistryPropertyW( set, &device_data, SPDRP_HARDWAREID, NULL, (BYTE *)bufferW,
+                                                sizeof(bufferW), NULL ))
+            goto done;
 
-                lstrcpyW( info->DeviceID, bufferW );
-                lstrcatW( info->DeviceID, L"\\" );
+        lstrcpyW( info->device_id, bufferW );
+        lstrcatW( info->device_id, L"\\" );
 
-                if (!SetupDiGetDeviceRegistryPropertyW( set, &device_data, SPDRP_DRIVER, NULL, (BYTE *)bufferW,
-                                                        sizeof(bufferW), NULL ))
-                    goto done;
+        if (!SetupDiGetDeviceRegistryPropertyW( set, &device_data, SPDRP_DRIVER, NULL, (BYTE *)bufferW,
+                                                sizeof(bufferW), NULL ))
+            goto done;
 
-                lstrcatW( info->DeviceID, bufferW );
-            }
-        }
+        lstrcatW( info->device_id, bufferW );
     }
 
     ret = TRUE;
 done:
-    release_display_device_init_mutex( mutex );
     SetupDiDestroyDeviceInfoList( set );
     if (ret)
         return ret;
@@ -4294,17 +4429,12 @@ done:
     /* Adapter */
     if (!device)
     {
-        lstrcpyW( info->DeviceName, L"\\\\.\\DISPLAY1" );
-        lstrcpyW( info->DeviceString, L"Wine Adapter" );
-        info->StateFlags =
-            DISPLAY_DEVICE_ATTACHED_TO_DESKTOP | DISPLAY_DEVICE_PRIMARY_DEVICE | DISPLAY_DEVICE_VGA_COMPATIBLE;
-        if (info->cb >= offsetof(DISPLAY_DEVICEW, DeviceID) + sizeof(info->DeviceID))
-        {
-            if (flags & EDD_GET_DEVICE_INTERFACE_NAME)
-                info->DeviceID[0] = 0;
-            else
-                lstrcpyW( info->DeviceID, L"PCI\\VEN_0000&DEV_0000&SUBSYS_00000000&REV_00" );
-        }
+        lstrcpyW( info->device_name, L"\\\\.\\DISPLAY1" );
+        lstrcpyW( info->device_string, L"Wine Adapter" );
+        info->state_flags = DISPLAY_DEVICE_ATTACHED_TO_DESKTOP | DISPLAY_DEVICE_PRIMARY_DEVICE | DISPLAY_DEVICE_VGA_COMPATIBLE;
+        info->interface_name[0] = 0;
+        lstrcpyW( info->device_id, L"PCI\\VEN_0000&DEV_0000&SUBSYS_00000000&REV_00" );
+        info->device_key[0] = 0;
     }
     /* Monitor */
     else
@@ -4312,21 +4442,14 @@ done:
         if (lstrcmpiW( L"\\\\.\\DISPLAY1", device ))
             return FALSE;
 
-        lstrcpyW( info->DeviceName, L"\\\\.\\DISPLAY1\\Monitor0" );
-        lstrcpyW( info->DeviceString, L"Generic Non-PnP Monitor" );
-        info->StateFlags = DISPLAY_DEVICE_ACTIVE | DISPLAY_DEVICE_ATTACHED;
-        if (info->cb >= offsetof(DISPLAY_DEVICEW, DeviceID) + sizeof(info->DeviceID))
-        {
-            if (flags & EDD_GET_DEVICE_INTERFACE_NAME)
-                lstrcpyW( info->DeviceID, L"\\\\\?\\DISPLAY#Default_Monitor#4&17f0ff54&0&UID0#{e6f07b5f-ee97-4a90-b076-33f57bf4eaa7}" );
-            else
-                lstrcpyW( info->DeviceID, L"MONITOR\\Default_Monitor\\{4d36e96e-e325-11ce-bfc1-08002be10318}\\0000" );
-        }
+        lstrcpyW( info->device_name, L"\\\\.\\DISPLAY1\\Monitor0" );
+        lstrcpyW( info->device_string, L"Generic Non-PnP Monitor" );
+        info->state_flags = DISPLAY_DEVICE_ACTIVE | DISPLAY_DEVICE_ATTACHED;
+        lstrcpyW( info->interface_name, L"\\\\\?\\DISPLAY#Default_Monitor#4&17f0ff54&0&UID0#{e6f07b5f-ee97-4a90-b076-33f57bf4eaa7}" );
+        lstrcpyW( info->device_id, L"MONITOR\\Default_Monitor\\{4d36e96e-e325-11ce-bfc1-08002be10318}\\0000" );
+        info->device_key[0] = 0;
     }
 
-    if (info->cb >= offsetof(DISPLAY_DEVICEW, DeviceKey) + sizeof(info->DeviceKey))
-        info->DeviceKey[0] = 0;
-
     return TRUE;
 }
 

-- 
2.30.2

From: Zhiyi Zhang <zzhang@codeweavers.com>
Subject: [PATCH 6/6] winex11.drv: Add a cache for querying XRandR 1.4 current modes.
Message-Id: <ce653baf-c8fd-aeaa-ce09-1e07b527c71c@codeweavers.com>
Date: Tue, 18 May 2021 17:14:29 +0800

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51047
Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/winex11.drv/xrandr.c | 124 ++++++++++++++++++++++++++++++++------
 1 file changed, 106 insertions(+), 18 deletions(-)

diff --git a/dlls/winex11.drv/xrandr.c b/dlls/winex11.drv/xrandr.c
index fa748c2af04..c3af35d8ec3 100644
--- a/dlls/winex11.drv/xrandr.c
+++ b/dlls/winex11.drv/xrandr.c
@@ -324,6 +324,32 @@ static LONG xrandr10_set_current_mode( ULONG_PTR id, DEVMODEW *mode )
 
 #ifdef HAVE_XRRGETPROVIDERRESOURCES
 
+static struct current_mode
+{
+    ULONG_PTR id;
+    BOOL loaded;
+    DEVMODEW mode;
+} *current_modes;
+static int current_mode_count;
+
+static CRITICAL_SECTION current_modes_section;
+static CRITICAL_SECTION_DEBUG current_modes_critsect_debug =
+{
+    0, 0, &current_modes_section,
+    {&current_modes_critsect_debug.ProcessLocksList, &current_modes_critsect_debug.ProcessLocksList},
+     0, 0, {(DWORD_PTR)(__FILE__ ": current_modes_section")}
+};
+static CRITICAL_SECTION current_modes_section = {&current_modes_critsect_debug, -1, 0, 0, 0, 0};
+
+static void xrandr14_invalidate_current_mode_cache(void)
+{
+    EnterCriticalSection( &current_modes_section );
+    heap_free( current_modes);
+    current_modes = NULL;
+    current_mode_count = 0;
+    LeaveCriticalSection( &current_modes_section );
+}
+
 static XRRScreenResources *xrandr_get_screen_resources(void)
 {
     XRRScreenResources *resources = pXRRGetScreenResourcesCurrent( gdi_display, root_window );
@@ -1115,6 +1141,7 @@ static void xrandr14_free_monitors( struct x11drv_monitor *monitors )
 
 static BOOL xrandr14_device_change_handler( HWND hwnd, XEvent *event )
 {
+    xrandr14_invalidate_current_mode_cache();
     if (hwnd == GetDesktopWindow() && GetWindowThreadProcessId( hwnd, NULL ) == GetCurrentThreadId())
     {
         /* Don't send a WM_DISPLAYCHANGE message here because this event may be a result from
@@ -1148,7 +1175,8 @@ static void xrandr14_register_event_handlers(void)
 /* XRandR 1.4 display settings handler */
 static BOOL xrandr14_get_id( const WCHAR *device_name, ULONG_PTR *id )
 {
-    INT gpu_count, adapter_count, display_count = 0;
+    struct current_mode *tmp_modes, *new_current_modes = NULL;
+    INT gpu_count, adapter_count, new_current_mode_count = 0;
     INT gpu_idx, adapter_idx, display_idx;
     struct x11drv_adapter *adapters;
     struct x11drv_gpu *gpus;
@@ -1159,31 +1187,60 @@ static BOOL xrandr14_get_id( const WCHAR *device_name, ULONG_PTR *id )
     if (*end)
         return FALSE;
 
-    if (!xrandr14_get_gpus2( &gpus, &gpu_count, FALSE ))
-        return FALSE;
-
-    for (gpu_idx = 0; gpu_idx < gpu_count; ++gpu_idx)
+    /* Update cache */
+    EnterCriticalSection( &current_modes_section );
+    if (!current_modes)
     {
-        if (!xrandr14_get_adapters( gpus[gpu_idx].id, &adapters, &adapter_count ))
+        if (!xrandr14_get_gpus2( &gpus, &gpu_count, FALSE ))
         {
-            xrandr14_free_gpus( gpus );
+            LeaveCriticalSection( &current_modes_section );
             return FALSE;
         }
 
-        adapter_idx = display_idx - display_count;
-        if (adapter_idx < adapter_count)
+        for (gpu_idx = 0; gpu_idx < gpu_count; ++gpu_idx)
         {
-            *id = adapters[adapter_idx].id;
-            xrandr14_free_adapters( adapters );
-            xrandr14_free_gpus( gpus );
-            return TRUE;
-        }
+            if (!xrandr14_get_adapters( gpus[gpu_idx].id, &adapters, &adapter_count ))
+                break;
 
-        display_count += adapter_count;
-        xrandr14_free_adapters( adapters );
+            if (!new_current_modes)
+                tmp_modes = heap_alloc( adapter_count * sizeof(*tmp_modes) );
+            else
+                tmp_modes = heap_realloc( new_current_modes, (new_current_mode_count + adapter_count) * sizeof(*tmp_modes) );
+
+            if (!tmp_modes)
+            {
+                xrandr14_free_adapters( adapters );
+                break;
+            }
+            new_current_modes = tmp_modes;
+
+            for (adapter_idx = 0; adapter_idx < adapter_count; ++adapter_idx)
+            {
+                new_current_modes[new_current_mode_count + adapter_idx].id = adapters[adapter_idx].id;
+                new_current_modes[new_current_mode_count + adapter_idx].loaded = FALSE;
+            }
+            new_current_mode_count += adapter_count;
+            xrandr14_free_adapters( adapters );
+        }
+        xrandr14_free_gpus( gpus );
+
+        if (new_current_modes)
+        {
+            heap_free( current_modes );
+            current_modes = new_current_modes;
+            current_mode_count = new_current_mode_count;
+        }
     }
-    xrandr14_free_gpus( gpus );
-    return FALSE;
+
+    if (display_idx >= current_mode_count)
+    {
+        LeaveCriticalSection( &current_modes_section );
+        return FALSE;
+    }
+
+    *id = current_modes[display_idx].id;
+    LeaveCriticalSection( &current_modes_section );
+    return TRUE;
 }
 
 static void add_xrandr14_mode( DEVMODEW *mode, XRRModeInfo *info, DWORD depth, DWORD frequency,
@@ -1342,6 +1399,21 @@ static BOOL xrandr14_get_current_mode( ULONG_PTR id, DEVMODEW *mode )
     RECT primary;
     INT mode_idx;
 
+    EnterCriticalSection( &current_modes_section );
+    for (mode_idx = 0; mode_idx < current_mode_count; ++mode_idx)
+    {
+        if (current_modes[mode_idx].id != id)
+            continue;
+
+        if (!current_modes[mode_idx].loaded)
+            break;
+
+        memcpy( mode, &current_modes[mode_idx].mode, sizeof(*mode) );
+        LeaveCriticalSection( &current_modes_section );
+        return TRUE;
+    }
+    LeaveCriticalSection( &current_modes_section );
+
     screen_resources = xrandr_get_screen_resources();
     if (!screen_resources)
         goto done;
@@ -1400,6 +1472,21 @@ static BOOL xrandr14_get_current_mode( ULONG_PTR id, DEVMODEW *mode )
     mode->u1.s2.dmPosition.x = crtc_info->x - primary.left;
     mode->u1.s2.dmPosition.y = crtc_info->y - primary.top;
     ret = TRUE;
+
+    EnterCriticalSection( &current_modes_section );
+    for (mode_idx = 0; mode_idx < current_mode_count; ++mode_idx)
+    {
+        if (current_modes[mode_idx].id != id)
+            continue;
+
+        memcpy( &current_modes[mode_idx].mode, mode, sizeof(*mode) );
+        current_modes[mode_idx].mode.dmSize = sizeof(*mode);
+        current_modes[mode_idx].mode.dmDriverExtra = 0;
+        current_modes[mode_idx].loaded = TRUE;
+        break;
+    }
+    LeaveCriticalSection( &current_modes_section );
+
 done:
     if (crtc_info)
         pXRRFreeCrtcInfo( crtc_info );
@@ -1517,6 +1604,7 @@ done:
     if (output_info)
         pXRRFreeOutputInfo( output_info );
     pXRRFreeScreenResources( screen_resources );
+    xrandr14_invalidate_current_mode_cache();
     return ret;
 }
 

-- 
2.30.2

